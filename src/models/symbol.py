"""Symbol model class

This model represents the Symbol entity (contracts/securities).

Attributes:
- id: Internal surrogate key (INTEGER PRIMARY KEY, auto-increment)
- conid: IB contract ID (UNIQUE)
- symbol: Symbol ticker (e.g., 'AAPL')
- sec_type: Security type (STK, OPT, FUT, etc.)
- currency: Currency code (USD in Phase 1)
- exchange: Optional exchange
- name: Optional description/company name
- multiplier: Optional multiplier (for options/futures)
- expiry: Optional expiry date (YYYY-MM-DD format)
- strike: Optional strike price (for options)
- right: Optional option right ('C' or 'P')
- underlying_conid: Optional FK to underlying contract (for options)
- local_symbol: Optional IB localSymbol
- primary_exchange: Optional primary exchange
- created_at: Timestamp of creation
- updated_at: Timestamp of last update
"""

from src.database import Database
from src.models.active_model import ActiveModel, ActiveModelError


class Symbol(ActiveModel):
    table_name = "symbols"
    primary_key = "id"
    primary_key_type = "INTEGER"

    _allowed_fields = {
        "id",
        "conid",
        "symbol",
        "sec_type",
        "currency",
        "exchange",
        "name",
        "multiplier",
        "expiry",
        "strike",
        "right",
        "underlying_conid",
        "local_symbol",
        "primary_exchange",
        "created_at",
        "updated_at",
    }

    # Valid security types
    VALID_SEC_TYPES = {
        "STK",  # Stock
        "OPT",  # Option
        "FUT",  # Future
        "CASH",  # Cash/FX
        "BOND",  # Bond
        "CFD",  # Contract for Difference
        "FOP",  # Future Option
        "WAR",  # Warrant
        "IOPT",  # Index Option
    }

    # Valid option rights
    VALID_RIGHTS = {"C", "P"}

    def __init__(self, database: Database, **kwargs):
        """Initialize Symbol instance.

        Args:
            database: Database instance
            **kwargs: Symbol attributes

        Note:
            For INTEGER PRIMARY KEY, 'id' should not be provided for new records.
            It will be auto-generated by the database.
        """
        invalid_fields = set(kwargs.keys()) - self._allowed_fields

        if invalid_fields:
            raise ValueError(f"Invalid fields: {invalid_fields}")

        super().__init__(database, **kwargs)

    def __repr__(self):
        """String representation of Symbol."""
        if hasattr(self, "id") and self.id:
            return f"Symbol(id={self.id}, conid={self.conid}, symbol={self.symbol}, sec_type={self.sec_type})"
        return f"Symbol(conid={self.conid}, symbol={self.symbol}, sec_type={self.sec_type})"

    def _before_save(self):
        """Validate before saving."""
        self.validate()

    def validate(self):
        """Validate the symbol data.

        Raises:
            ActiveModelError: If validation fails
        """
        errors = []

        # Required fields
        if not hasattr(self, "conid") or self.conid is None:
            errors.append("conid is required for Symbol")

        if not hasattr(self, "symbol") or not self.symbol:
            errors.append("symbol is required for Symbol")

        if not hasattr(self, "sec_type") or not self.sec_type:
            errors.append("sec_type is required for Symbol")

        if not hasattr(self, "currency") or not self.currency:
            errors.append("currency is required for Symbol")

        # Currency validation (Phase 1: USD only)
        if hasattr(self, "currency") and self.currency != "USD":
            errors.append(f"Currency must be USD in Phase 1, but got {self.currency}")

        # Security type validation
        if hasattr(self, "sec_type") and self.sec_type not in self.VALID_SEC_TYPES:
            errors.append(
                f"sec_type must be one of {sorted(self.VALID_SEC_TYPES)}, "
                f"but got {self.sec_type}"
            )

        # Option-specific validations
        if hasattr(self, "sec_type") and self.sec_type == "OPT":
            if hasattr(self, "right") and self.right:
                if self.right not in self.VALID_RIGHTS:
                    errors.append(
                        f"right must be 'C' or 'P' for options, but got {self.right}"
                    )

            # Note: strike and expiry are optional in schema, but typically provided for options
            # We don't enforce them as required to allow flexibility

        # Validate underlying_conid is integer if provided
        if hasattr(self, "underlying_conid") and self.underlying_conid is not None:
            if not isinstance(self.underlying_conid, int):
                errors.append("underlying_conid must be an integer")

        # Check for invalid fields
        current_fields = set(self._get_attributes().keys())
        invalid_fields = current_fields - self._allowed_fields
        if invalid_fields:
            errors.append(
                f"Invalid fields detected before save: {sorted(invalid_fields)}"
            )

        if errors:
            raise ActiveModelError(f"Validation failed: {', '.join(errors)}")

    @classmethod
    def find_by_conid(cls, database: Database, conid: int) -> "Symbol | None":
        """Find symbol by IB contract ID.

        Args:
            database: Database instance
            conid: IB contract ID

        Returns:
            Symbol instance or None if not found
        """
        return cls.find_by(database, conid=conid)

    @classmethod
    def find_by_symbol(
        cls, database: Database, symbol: str, sec_type: str = "STK"
    ) -> "Symbol | None":
        """Find symbol by ticker and security type.

        Args:
            database: Database instance
            symbol: Symbol ticker
            sec_type: Security type (default: STK)

        Returns:
            Symbol instance or None if not found
        """
        return cls.find_by(database, symbol=symbol, sec_type=sec_type)
