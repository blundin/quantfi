"""Position model class

This model represents the Position entity (account positions at a point in time).

Attributes:
- id: Internal surrogate key (INTEGER PRIMARY KEY, auto-increment)
- account_id: Foreign key to accounts.id
- symbol_id: Foreign key to symbols.id
- quantity: Position quantity (shares for stocks, contracts for options)
- market_price: Current market price in INTEGER micro-dollars (nullable)
- market_value: Total market value in INTEGER micro-dollars (nullable)
- avg_cost: Average cost basis in INTEGER micro-dollars (nullable)
- currency: Currency code (USD in Phase 1)
- unrealized_pnl: Unrealized P&L in INTEGER micro-dollars (nullable)
- realized_pnl: Realized P&L in INTEGER micro-dollars (nullable)
- snapshot_ts: ISO-8601 snapshot timestamp
- created_at: Timestamp of creation
- updated_at: Timestamp of last update
"""

from __future__ import annotations

from datetime import datetime
from typing import Any

from src.database import Database
from src.models.account import Account
from src.models.active_model import ActiveModel, ActiveModelError
from src.models.symbol import Symbol


class Position(ActiveModel):
    table_name = "positions"
    primary_key = "id"
    primary_key_type = "INTEGER"

    _allowed_fields = {
        "id",
        "account_id",
        "symbol_id",
        "quantity",
        "market_price",
        "market_value",
        "avg_cost",
        "currency",
        "unrealized_pnl",
        "realized_pnl",
        "snapshot_ts",
        "created_at",
        "updated_at",
    }

    def __init__(self, database: Database, **kwargs):
        """Initialize Position instance.

        Args:
            database: Database instance
            **kwargs: Position attributes

        Note:
            For INTEGER PRIMARY KEY, 'id' should not be provided for new records.
            It will be auto-generated by the database.
        """
        invalid_fields = set(kwargs.keys()) - self._allowed_fields

        if invalid_fields:
            raise ValueError(f"Invalid fields: {invalid_fields}")

        super().__init__(database, **kwargs)

    def __repr__(self):
        """String representation of Position."""
        if hasattr(self, "id") and self.id:
            return (
                f"Position(id={self.id}, account_id={self.account_id}, "
                f"symbol_id={self.symbol_id}, quantity={self.quantity})"
            )
        return (
            f"Position(account_id={self.account_id}, "
            f"symbol_id={self.symbol_id}, quantity={self.quantity})"
        )

    def _before_save(self):
        """Validate before saving."""
        self.validate()

    def validate(self):
        """Validate the position data.

        Raises:
            ActiveModelError: If validation fails
        """
        errors = []

        # Required fields
        if not hasattr(self, "account_id") or not self.account_id:
            errors.append("account_id is required for Position")

        if not hasattr(self, "symbol_id") or self.symbol_id is None:
            errors.append("symbol_id is required for Position")

        if not hasattr(self, "quantity") or self.quantity is None:
            errors.append("quantity is required for Position")

        if not hasattr(self, "currency") or not self.currency:
            errors.append("currency is required for Position")

        if not hasattr(self, "snapshot_ts") or not self.snapshot_ts:
            errors.append("snapshot_ts is required for Position")

        # Currency validation (Phase 1: USD only)
        if hasattr(self, "currency") and self.currency != "USD":
            errors.append(f"Currency must be USD in Phase 1, but got {self.currency}")

        # Validate account exists
        if hasattr(self, "account_id") and self.account_id:
            account = Account.find_by_id(self._database, self.account_id)
            if account is None:
                errors.append(f"Account {self.account_id} does not exist")

        # Validate symbol exists
        if hasattr(self, "symbol_id") and self.symbol_id is not None:
            symbol = Symbol.find_by_id(self._database, self.symbol_id)
            if symbol is None:
                errors.append(f"Symbol {self.symbol_id} does not exist")

        # Validate quantity is numeric
        if hasattr(self, "quantity") and self.quantity is not None:
            try:
                float(self.quantity)
            except (ValueError, TypeError):
                errors.append("quantity must be numeric")

        # Validate snapshot_ts is valid ISO-8601 format
        if hasattr(self, "snapshot_ts") and self.snapshot_ts:
            try:
                # Handle Z timezone suffix (Python 3.11+ supports it directly,
                # but we normalize for compatibility)
                ts_str = (
                    self.snapshot_ts.replace("Z", "+00:00")
                    if "Z" in self.snapshot_ts
                    else self.snapshot_ts
                )
                datetime.fromisoformat(ts_str)
            except (ValueError, AttributeError):
                errors.append(
                    f"snapshot_ts must be valid ISO-8601 format, got {self.snapshot_ts}"
                )

        # Validate currency amounts are integers if provided
        currency_fields = [
            "market_price",
            "market_value",
            "avg_cost",
            "unrealized_pnl",
            "realized_pnl",
        ]
        for field in currency_fields:
            if hasattr(self, field) and getattr(self, field, None) is not None:
                if not isinstance(getattr(self, field), int):
                    errors.append(
                        f"{field} must be INTEGER (micro-dollars), "
                        f"got {type(getattr(self, field)).__name__}"
                    )

        # Check for invalid fields
        current_fields = set(self._get_attributes().keys())
        invalid_fields = current_fields - self._allowed_fields
        if invalid_fields:
            errors.append(
                f"Invalid fields detected before save: {sorted(invalid_fields)}"
            )

        if errors:
            raise ActiveModelError(f"Validation failed: {', '.join(errors)}")

    @classmethod
    def create_from_api_data(
        cls,
        database: Database,
        account_id: str,
        conid: int,
        symbol: str,
        sec_type: str,
        quantity: float,
        snapshot_ts: str,
        currency: str = "USD",
        market_price: int | None = None,
        market_value: int | None = None,
        avg_cost: int | None = None,
        unrealized_pnl: int | None = None,
        realized_pnl: int | None = None,
        # Optional symbol fields for automatic creation
        symbol_name: str | None = None,
        exchange: str | None = None,
        multiplier: float | None = None,
        expiry: str | None = None,
        strike: float | None = None,
        right: str | None = None,
        underlying_conid: int | None = None,
        local_symbol: str | None = None,
        primary_exchange: str | None = None,
    ) -> Position:
        """Create Position from API data, automatically creating Symbol if needed.

        This is the primary method for creating positions from IBKR Web API data.
        It ensures the Symbol exists (creating it if necessary) before creating
        the Position.

        Args:
            database: Database instance
            account_id: Account ID
            conid: IB contract ID
            symbol: Symbol ticker
            sec_type: Security type (STK, OPT, etc.)
            quantity: Position quantity
            snapshot_ts: ISO-8601 snapshot timestamp
            currency: Currency code (default: USD)
            market_price: Market price in INTEGER micro-dollars (optional)
            market_value: Market value in INTEGER micro-dollars (optional)
            avg_cost: Average cost in INTEGER micro-dollars (optional)
            unrealized_pnl: Unrealized P&L in INTEGER micro-dollars (optional)
            realized_pnl: Realized P&L in INTEGER micro-dollars (optional)
            symbol_name: Optional symbol name/description
            exchange: Optional exchange
            multiplier: Optional multiplier (for options/futures)
            expiry: Optional expiry date (YYYY-MM-DD)
            strike: Optional strike price (for options)
            right: Optional option right ('C' or 'P')
            underlying_conid: Optional underlying contract ID (for options)
            local_symbol: Optional IB localSymbol
            primary_exchange: Optional primary exchange

        Returns:
            Position instance

        Raises:
            ActiveModelError: If validation fails
            ValueError: If account does not exist
        """
        # Verify account exists
        account = Account.find_by_id(database, account_id)
        if account is None:
            raise ValueError(f"Account {account_id} does not exist")

        # Find or create Symbol
        symbol_obj = Symbol.find_by_conid(database, conid)
        if symbol_obj is None:
            # Create Symbol with provided data
            symbol_data: dict[str, Any] = {
                "conid": conid,
                "symbol": symbol,
                "sec_type": sec_type,
                "currency": currency,
            }

            # Add optional symbol fields if provided
            if symbol_name:
                symbol_data["name"] = symbol_name
            if exchange:
                symbol_data["exchange"] = exchange
            if multiplier is not None:
                symbol_data["multiplier"] = multiplier
            if expiry:
                symbol_data["expiry"] = expiry
            if strike is not None:
                symbol_data["strike"] = strike
            if right:
                symbol_data["right"] = right
            if underlying_conid is not None:
                symbol_data["underlying_conid"] = underlying_conid
            if local_symbol:
                symbol_data["local_symbol"] = local_symbol
            if primary_exchange:
                symbol_data["primary_exchange"] = primary_exchange

            symbol_obj = Symbol(database, **symbol_data)
            symbol_obj.save()

        # Create Position
        position_data: dict[str, Any] = {
            "account_id": account_id,
            "symbol_id": symbol_obj.id,
            "quantity": quantity,
            "currency": currency,
            "snapshot_ts": snapshot_ts,
        }

        # Add optional position fields if provided
        if market_price is not None:
            position_data["market_price"] = market_price
        if market_value is not None:
            position_data["market_value"] = market_value
        if avg_cost is not None:
            position_data["avg_cost"] = avg_cost
        if unrealized_pnl is not None:
            position_data["unrealized_pnl"] = unrealized_pnl
        if realized_pnl is not None:
            position_data["realized_pnl"] = realized_pnl

        position = cls(database, **position_data)
        position.save()

        return position

    @classmethod
    def find_by_account(cls, database: Database, account_id: str) -> list[Position]:
        """Find all positions for an account.

        Args:
            database: Database instance
            account_id: Account ID

        Returns:
            List of Position instances
        """
        return cls.where(database, account_id=account_id)

    @classmethod
    def find_by_account_and_symbol(
        cls, database: Database, account_id: str, symbol_id: int
    ) -> list[Position]:
        """Find positions for an account and symbol.

        Args:
            database: Database instance
            account_id: Account ID
            symbol_id: Symbol ID

        Returns:
            List of Position instances
        """
        return cls.where(database, account_id=account_id, symbol_id=symbol_id)

    @classmethod
    def find_latest_by_account_and_symbol(
        cls, database: Database, account_id: str, symbol_id: int
    ) -> Position | None:
        """Find the latest position snapshot for an account and symbol.

        Args:
            database: Database instance
            account_id: Account ID
            symbol_id: Symbol ID

        Returns:
            Latest Position instance or None if not found
        """
        positions = cls.find_by_account_and_symbol(database, account_id, symbol_id)
        if not positions:
            return None

        # Sort by snapshot_ts descending and return the first (latest)
        # snapshot_ts is required, so it should always exist
        # Use getattr with empty string fallback for safety
        positions.sort(key=lambda p: getattr(p, "snapshot_ts", ""), reverse=True)
        return positions[0]
